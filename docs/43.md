# 从Cython0.29迁移到3.0
> 原文：[http://docs.cython.org/en/latest/src/userguide/migrating_to_cy30.html](http://docs.cython.org/en/latest/src/userguide/migrating_to_cy30.html)

Cython3.0是语言和编译器的一次大更新，带来了一些不可向后兼容的修改。这个文档将会列出**其中比较重要**的内容并说明如果在现有代码中处理。

## Python 3 语法/语义

Cython 3.0 现在默认使用Python3语法和语义，在之前的版本中需要设置 `language_level` 编译器指令为 `3` 或者 `3str` 来实现。现在编译器指令的默认设置是 `language_level=3str`，这代表默认使用Python3语义，但是没有前缀修饰的字符串仍然是 `str` 对象，比如：在Python3中是Unicode文本，Python2.7中是字节字符串。

通过设置 `language_level=2` 你可以让你的代码回到使用Python2语义的模式。

根据语言级别一起变化的语义还有：
- `/` 除法，使用true除法运算符，除非启用 `cdivison` 编译器指令。
- `print` 是一个函数而不是语句
- 没有定义基类( `class C: ...` )的Python类现在是“新式”的类了，在Py2.X中也是。如果你从没听过什么是“旧风格的类”，你大概率也没必要知道。
- 注解（类型提示）现在以字符串的形式存储。[PEP 563](https://github.com/cython/cython/issues/2863)
- 根据[PEP 479](https://www.python.org/dev/peps/pep-0479/) 生成器中 `StopIteration` 的处理方式变了。

## Python 语义

一些Python兼容性的BUG被修复了，比如：
- 下标访问（ `x[1]` ）会在尝试序列协议之前先尝试映射协议。[https://github.com/cython/cython/issues/1807](https://github.com/cython/cython/issues/1807) （译者注：就是先把x看作dict后看作list来尝试。）
- 整数字面量的指数现在遵循Python语义而不是C语义。[https://github.com/cython/cython/issues/2133](https://github.com/cython/cython/issues/2133)

## 绑定函数

[binding directive]() 编译器指令现在默认启用。这使得Cython编译的Python函数和普通的（没有编译的）的Python函数在大多数方面兼容，比如签名自省、注解等等。（译者注：自省是指对象可以提供查看自身属性、方法、类型的手段）。

这也使得他们可以通过属性赋值的方式绑定在Python类上。如果你不想要这样，比如：函数就是函数不应该成为方法，你可以通过设置 `binding=False` 或者有选择性的增加 `@cython.binding(False)` 装饰器来禁用“绑定”（以及所有其他Python函数特性）。在纯Python风格下，到Cython0.29.16版本为止，这个装饰器还没有被提供，但是编译过的代码不受此影响。

无论如何，我们推荐用标准的Python内置函数 `staticmethod` 来保留新的函数特性而不是处理绑定问题。

```python
def func(self, b): ...

class MyClass(object):
    binding_method = func

    no_method = staticmethod(func)

```

## 命名空间包

根据[PEP-420](https://www.python.org/dev/peps/pep-0420/), Cython现在还支持从命名空间包中加载pxd文件。这可能会对引用路径造成影响。

## NumPy C-API

Cython过去基于过时的 pre-NumPy-1.7 C-API 来生成代码。Cython3.0起不再是这样了。

你可以通过定义宏 `NPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION` 来去掉长久以来的构建警告：“编译器的C模块使用了过时的API”。要么在每个文件中：

```python
# distutils: define_macros=NPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION
```

要么在你的 `setup.py` 的 Extension对象中：

```python
Extension(...
    define_macros=[("NPY_NO_DEPRECATED_API", "NPY_1_7_API_VERSION")]
)
```

使用不同的C-API的一个副作用是你的代码现在需要调用 [NumPy C-API 初始化函数](https://docs.scipy.org/doc/numpy-1.17.0/reference/c-api.array.html#importing-the-api) -- 之前的版本中不必这么做。

为了这一点降低对用户对影响，当Cython3.0看到 `numpy` 被 `cimport` 但是函数还没有被使用的时候会自动调用（这个初始化函数）。在那些你不需要这么做（希望很少）的场景下，内部C-API的初始化可以被通过伪造一次函数使用但是并不真的调用来禁用，比如：

```python
# 显式禁用 NumPy's C-API 的自动初始化.
<void>import_array
```

## 类私有名称的损毁

Cython更新后会更遵循[Python对于类私有名称的规则](https://docs.python.org/3/tutorial/classes.html#private-variables)。任何类内部以 `__` 开头但是不以 `__` 结尾的名称都会用类名称毁坏。大多数用户的代码应该不受影响 - 和Python不同的是，没有毁坏的全局名称仍然可以访问以保证能够访问以 `__` 开头的C名称。

```python
cdef extern void __foo()

class C: # or "cdef class"
   def call_foo(self):
       return __foo() # 调用的仍然是全局名称

```

覆盖 `cdef class` 里的 `__` 开头的方法将变得无效。

```python
cdef class Base:
    cdef __bar(self):
        return 1

    def call_bar(self):
        return self.__bar()

cdef class Derived(Base):
    cdef __bar(self):
        return 2

```

这里
