# 故障排除

> 原文: [https://cython.readthedocs.io/en/latest/src/userguide/troubleshooting.html](https://cython.readthedocs.io/en/latest/src/userguide/troubleshooting.html)

这个文档提供了一些关于常见错误的故障排查建议。如果你用Cython时遇到了问题，那么有必要读一下。如果你遇到了一个常见的、但是这里没有提到的错误。我们很欢迎你给这个章节提Pull Request。

## 语言的混乱区

当然，Cython是一个奇怪的混合物：它有Python运行时解析、动态的行为；它也有C一样编译器解析、静态确定的行为。这些肯定不能完美的结合在一起，这两者交汇的地方也通常是经常让人混淆的地方。

比如说，对于一个 `cdef class`, Cython可以直接访问它的 `cdef` 属性（通过一个简单的C查找）。但是，如果直接属性查找没找到，Cython不会产生任何错误信息 -- 相反，它会假设能够在运行的时候通过标准Python的“从字典中查找字符串“的方式能够解析这个属性。这两个机制在工作方式和返回值方面都相当不同（Python机制只能返回Python对象，C直接查找可以反悔几乎任何C类型）。

当一个名称被引入( `import` ) 而不是 ( `cimport` ) 的时候也会发生类似的事 - Cython并不知道名称从哪里来 - 因此它假设这是一个普通的Python对象。

这种默默的的失败然后交给Python的行为经常会造成混乱。最好的情况下，它的总体行为完全一致，但是稍慢（比如通过Python机制调用 `cpdef` 函数而不是直接调用C函数）。很多时候，它只会在运行期间引发一个 `AttributeError` 异常。偶尔，它会做点不同的事 -- 调用和 `cdef` 方法名称相同的Python方法 或者引发 C ++容器到Python容器的类型转换。

这种双层的行为机制大概不是用来从零设计一门语言的，但是对于Cython的目标来说很有必要 -- 既兼容Python又允许相当流畅的使用C类型。

## 属性错误

### 未标记类型的对象

遇到 `AttributeError` 的一个常见原因是Cython不知道你的对象的类型：

```python
cdef class Counter:
    cdef int count_so_far

    ...
```

count_so_far 这个属性只在Cyton代码中可以访问，Cython通过在它定义的 `Counter` 结构中通过C直接查找（真的很快！）。现在尝试对一组 `Counter` 对象运行下面这个方法。

```
def bigger_count(c1, c2):
    return c1.count_so_far < c2.count_so_far
```

这会引发 `AttributeError` 因为Cython并不知道 `c1` 和 `c2` 的类型是什么。把它们限定为 `Counter c1` 和 `Counter c2` 可以解决这个问题：

```python
def bigger_count(c1, c2):
    return c1.count_so_far < c2.count_so_far

```

对于全局对象来说，这个问题会换一种形式发生：

```python
def count_something():
    c = Counter()

    # code goes here!!!

    print(c.count_so_far)  # 有效

global_count = Counter()
print(global_count.count_so_far)  # 属性错误

```

在函数中，Cython通常能够完成类型推理。所以即时你不告诉它，它也知道 `c` 是一个 `Counter`。但是在 *全局和模块* 的层面就不是这样了。这里有一个非常强的假设：你希望所有对象都是Python模块的属性（请记得Python属性可以在任何地方被修改），因此Cython会根本上禁止类型推理。因此它并不知道 `global_count` 的类型。

### 写入扩展类型

`AttributeError` 也可以在写入 `cdef class` 的时候发生，通常是在 `__init__` 中：

